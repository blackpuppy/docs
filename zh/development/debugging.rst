调试 Debugging
#########

调试在任何开发环节中都是不可避免和必要的。CakePHP并没有提供任何可以直接连接IDE或编辑器的工具，
但提供了能够协助调试和显示在应用程序下内容的方法。

Debugging is an inevitable and necessary part of any development
cycle. While CakePHP doesn't offer any tools that directly connect
with any IDE or editor, CakePHP does provide several tools to
assist in debugging and exposing what is running under the hood of
your application.

基本调试 Basic Debugging
===============

.. php:function:: debug(mixed $var, boolean $showHtml = null, $showFrom = true)

    :param mixed $var: 要打印的内容，可以是数组或对象等类型。
    :param boolean $showHTML: 为true，将转义内容。在2.0版本中，默认会转义web请求的内容。
    :param boolean $showFrom: 显示执行debug()的行号和文件。

debug()函数是一个全局函数，和PHP的print_r()函数类似，
debug()函数可以以不同的形式显示内容。如果若要HTML友好的输出，可以设置第二个参数为true。
默认情况下会输出调用debug()函数的行号和文件。
只有在配置文件中把debug变量的值设的大于0才有输出内容显示。

.. versionchanged:: 2.1 
    ``debug()``的输出内容和``var_dump()``很相似,因为在内部类:php:class:`Debugger`中他使用这个函数。

Debugger Class
==============

debugger调试类是在CakePHP 1.2中引入的，提供了很多获得调试信息的选项。
. 其中包含了一些调用静态，输出内容日志和错误处理。

The debugger class was introduced with CakePHP 1.2 and offers even
more options for obtaining debugging information. It has several
functions which are invoked statically, and provide dumping,
logging, and error handling functions.

Debugger类重载了PHP默认的错误处理函数，替换为了更实用的错误报告功能。
调试器的错误处理默认使用的是CakePHP。所有的调试函数必须在``Configure::debug``
的值大于0的情况下才生效。

The Debugger Class overrides PHP's default error handling,
replacing it with far more useful error reports. The Debugger's
error handling is used by default in CakePHP. As with all debugging
functions, ``Configure::debug`` must be set to a value higher than 0.

当一个错误发生，调试器在页面上输出信息并且会将信息写入error.log错误日志中。
错误报告会生成一个代码发生错误根源的堆栈追踪记录。点击"Error"链接，显示堆栈跟踪
"Code"链接显示错误发生的行。

When an error is raised, Debugger both outputs information to the
page and makes an entry in the error.log file. The error report
that is generated has both a stack trace and a code excerpt from
where the error was raised. Click on the "Error" link type to
reveal the stack trace, and on the "Code" link to reveal the
error-causing lines.

使用Debugger调试类

Using the Debugger Class
========================

.. php:class:: Debugger

为了使用debugger，首先要确保Configure::read('debug')的值大于0。

To use the debugger, first ensure that Configure::read('debug') is
set to a value greater than 0.

.. php:staticmethod:: Debugger::dump($var)

    将变量的内容全部输出，包含所有的属性和方法(如果存在任何方法)::

    Dump prints out the contents of a variable. It will print out all
    properties and methods (if any) of the supplied variable::

        $foo = array(1,2,3);

        Debugger::dump($foo);

        // 输出
        array(
            1,
            2,
            3
        )

        // 简单的对象
        $car = new Car();

        Debugger::dump($car);

        // 输出
        Car
        Car::colour = 'red'
        Car::make = 'Toyota'
        Car::model = 'Camry'
        Car::mileage = '15000'
        Car::accelerate()
        Car::decelerate()
        Car::stop()

    .. versionchanged:: 2.1

        在2.1为提高输出内容的可读性，详见:php:func:`Debugger::exportVar()`
        In 2.1 forward the output was updated for readability. See
        :php:func:`Debugger::exportVar()`

.. php:staticmethod:: Debugger::log($var, $level = 7)

    调用时创建一个详细堆栈追踪记录的日志。log()的输出内容和Debugger::dump()相似，
    他不是输出缓冲而是写入debug.log日志中。注意要使服务器对app/tmp目录具有可写权限。

    Creates a detailed stack trace log at the time of invocation. The
    log() method prints out data similar to that done by
    Debugger::dump(), but to the debug.log instead of the output
    buffer. Note your app/tmp directory (and its contents) must be
    writable by the web server for log() to work correctly.

.. php:staticmethod:: Debugger::trace($options)

    返回当前的堆栈追踪记录，每行显示被调用的方法，包含文件及行号的来源。

    Returns the current stack trace. Each line of the trace includes
    the calling method, including which file and line the call
    originated from.::

        //In PostsController::index()
        pr(Debugger::trace());
        
        //输出
        PostsController::index() - APP/Controller/DownloadsController.php, line 48
        Dispatcher::_invoke() - CORE/lib/Cake/Routing/Dispatcher.php, line 265
        Dispatcher::dispatch() - CORE/lib/Cake/Routing/Dispatcher.php, line 237
        [main] - APP/webroot/index.php, line 84

    上面的堆栈追踪记录是在一个控制器的动作中调用Debugger::trace()产生的。
    在上面的例子中，index.php调用了Dispatcher::dispatch()，他又依次调用了Dispatcher::\_invoke()，
    \_invoke()又调用了PostsController::index()。这个信息在循环操作和深层堆栈的工作情况下很方便。
    它还能够识别哪些功能是目前运行在trace()。

    Above is the stack trace generated by calling Debugger::trace() in
    a controller action. Reading the stack trace bottom to top shows
    the order of currently running functions (stack frames). In the
    above example, index.php called Dispatcher::dispatch(), which
    in-turn called Dispatcher::\_invoke(). The \_invoke() method then
    called PostsController::index(). This information is useful when
    working with recursive operations or deep stacks, as it identifies
    which functions are currently running at the time of the trace().

.. php:staticmethod:: Debugger::excerpt($file, $line, $context)


    获得$path(绝对路径)所指向的文件的摘要，并高亮凸显位于第$line行前后$context行的内容。
    Grab an excerpt from the file at $path (which is an absolute
    filepath), highlights line number $line with $context number of
    lines around it.::

        pr(Debugger::excerpt(ROOT . DS . LIBS . 'debugger.php', 321, 2));
        
        //因为$context参数为2，会返回debugger.php文件中第219-323行之间的内容
        Array
        (
            [0] => <code><span style="color: #000000"> * @access public</span></code>
            [1] => <code><span style="color: #000000"> */</span></code>
            [2] => <code><span style="color: #000000">    function excerpt($file, $line, $context = 2) {</span></code>
         
            [3] => <span class="code-highlight"><code><span style="color: #000000">        $data = $lines = array();</span></code></span>
            [4] => <code><span style="color: #000000">        $data = @explode("\n", file_get_contents($file));</span></code>
        )

    虽然这种方法在内部使用,在你要创建自己的错误消息或自定义日志条目的
    情况下使用他很方便。
   
    Although this method is used internally, it can be handy if you're
    creating your own error messages or log entries for custom
    situations.

.. php:staticmethod:: Debugger::exportVar($var, $recursion = 0)


    将一个变量的类型转成字符串用于调试输出。这个方法同样也被调试器进行内部变量转换，
    同样也能作为你自己的调试器。
    
    Converts a variable of any type to a string for use in debug
    output. This method is also used by most of Debugger for internal
    variable conversions, and can be used in your own Debuggers as
    well.

    .. versionchanged:: 2.1
        This function generates different output in 2.1 forward.

.. php:staticmethod:: Debugger::invoke($debugger)

    替换CakePHP的调试器为新实例

    Replace the CakePHP Debugger with a new instance.

.. php:staticmethod:: Debugger::getType($var)

    返回变量的类型，对象将返回他们的类名。
    Get the type of a variable.  Objects will return their classname

    .. versionadded:: 2.1

通过日志消息进行调试
Using Logging to debug
======================

日志消息是另一个调试应用的好方法，你可以使用:php:class:`CakeLog`在应用中进行日志调试。
所有的对象都
Logging messages is another good way to debug applications, and you can use
:php:class:`CakeLog` to do logging in your application.  All objects that 
extend :php:class:`Object` have an instance method `log()` which can be used
to log messages::

    $this->log('Got here', 'debug');

上面的代码会把``Got here``写如debug日志中，你可以使用日志来帮助调试牵涉到重定向和复杂的循环。
也可以使用:php:meth:`CakeLog::write()`来写入日志信息。这个方法可以在程序中的任何调用。

The above would write ``Got here`` into the debug log.  You can use log entries
to help debug methods that involve redirects or complicated loops. You can also
use :php:meth:`CakeLog::write()` to write log messages.  This method can be called
statically anywhere in your application one CakeLog has been loaded::

    // in app/Config/bootstrap.php
    App::uses('CakeLog', 'Log');

    // Anywhere in your application
    CakeLog::write('debug', 'Got here');

Debug Kit
=========

DebugKit 是一个提供很多调试工具的插件，主要在html中多出了一个工具栏，用来显示程序中的请求信息。
你可以到github站点下载`DebugKit <https://github.com/cakephp/debug_kit>`_ 

DebugKit is a plugin that provides a number of good debugging tools. It primarily
provides a toolbar in the rendered HTML, that provides a plethora of information about 
your application and the current request. You can download 
`DebugKit <https://github.com/cakephp/debug_kit>`_ from github.


.. meta::
    :title lang=zh_CN: Debugging
    :description lang=zh_CN: Debugging CakePHP with the Debugger class, logging, basic debugging and using the DebugKit plugin.
    :keywords lang=zh_CN: code excerpt,stack trace,default output,error link,default error,web requests,error report,debugger,arrays,different ways,excerpt from,cakephp,ide,options
